{"name":"Employee-manual","tagline":"The Fluid Media Inc. Employee Manual","body":"# Welcome to Fluid Media\r\n\r\nThe goal of this manual is to guide your first couple of weeks at Fluid Media. The manual is composed of several sections. The first couple of sections will help to introduce your workstations and the various tools you'll use in your everyday development, most notably source control.\r\n\r\n> #### Note\r\nThis manual is available on github. If you spot any errors, omissions, or would like to contribute, please don't hesitate to create a pull-request (this manual will explain how to that shortly)\r\n\r\n## Workstations\r\n\r\n> \"This is my workstation, there are many like it but this one is mine.\"\r\n\r\nYour workstations have been setup to be development ready. We use a provisioning tool called *KitchenPlan* to automate setup and configuration of development machines. The company's KitchenPlan repo is maintained [here](https://github.com/fmitech/kitchenplan/tree/version2). Take a look if you're curious how the machine was setup.\r\n\r\nYou can add/modify features/applications based on your prefrence.\r\n\r\n### Installed applications/components\r\n\r\nAlong with the base operating system, the following additional software has also been installed.\r\n\r\n#### Sublime Text 3\r\n\r\nA great text editor. [More information.](http://www.sublimetext.com/3)\r\n\r\nThere are tons of useful plugins available for Sublime Text. The vast majority of them can be installed via [Package Control](https://sublime.wbond.net/). You can browse packages [online](https://sublime.wbond.net/browse) and then use the Command Palette to install.\r\n\r\n[insert how-to pics here]\r\n\r\nSome useful plugins have already been installed.\r\n\r\n| Package | Description |\r\n| ------- | ----------- |\r\n| [AdvancedNewFile](https://sublime.wbond.net/packages/AdvancedNewFile) | Allows for faster file creation within a project |\r\n| [Alignment](https://sublime.wbond.net/packages/Alignment) | Key-binding for aligning multi-line and multiple selections |\r\n| [Bracketâ€‹Highlighter](https://sublime.wbond.net/packages/BracketHighlighter) | Matcher for a variety of brackets |\r\n| [Emmet](https://sublime.wbond.net/packages/Emmet) | Zen-Coding |\r\n| [Git](https://sublime.wbond.net/packages/Git) | Git integration |\r\n| [GitGutter](https://sublime.wbond.net/packages/GitGutter) | Show git line status in gutter |\r\n| [SideBarEnhancements](https://sublime.wbond.net/packages/SideBarEnhancements) | Enhances the Sidebar |\r\n| [Sass](https://sublime.wbond.net/packages/Sass) | Syntax highlighting and tab/code completion for Sass and SCSS files |\r\n| [SCSS](https://sublime.wbond.net/packages/SCSS) | Additional syntax for SCSS files |\r\n| [ApplySyntax](https://sublime.wbond.net/packages/ApplySyntax) | Syntax detector for a wide variety of files |\r\n| [Pretty JSON](https://sublime.wbond.net/packages/Pretty%20JSON) | Prettifies JSON documents |\r\n| [Theme - Soda](https://sublime.wbond.net/packages/Theme%20-%20Soda) | A UI Theme |\r\n| [Theme - Flatland](https://sublime.wbond.net/packages/Theme%20-%20Flatland) | A UI Theme |\r\n| [Theme - Spacegray](https://sublime.wbond.net/packages/Theme%20-%20Spacegray) | A UI Theme |\r\n| [Tomorrow Color Schemes](https://sublime.wbond.net/packages/Tomorrow%20Color%20Schemes) | Additional Color Schemes |\r\n\r\nIn addition, the following preferences have also been set. Feel free to customize these to your liking. To modify, _Preferences > Settings - User_.\r\n\r\n```JSON\r\n{\r\n\t\"auto_complete\": true,\r\n\t\"auto_complete_commit_on_tab\": true,\r\n\t\"auto_complete_with_fields\": true,\r\n\t\"bold_folder_labels\": true,\r\n\t\"color_scheme\": \"Packages/Tomorrow Color Schemes/Tomorrow-Night.tmTheme\",\r\n\t\"ensure_newline_at_eof_on_save\": true,\r\n\t\"fade_fold_buttons\": false,\r\n\t\"file_exclude_patterns\":\r\n\t[\r\n\t\t\".DS_Store\",\r\n\t\t\".gitkeep\",\r\n\t\t\"dump.rdb\"\r\n\t],\r\n\t\"folder_exclude_patterns\":\r\n\t[\r\n\t\t\".svn\",\r\n\t\t\".git\",\r\n\t\t\".hg\",\r\n\t\t\"CVS\",\r\n\t\t\"tmp\",\r\n\t\t\".bundle\",\r\n\t\t\".sass-cache\",\r\n\t\t\"log\",\r\n\t\t\"cache\"\r\n\t],\r\n\t\"font_face\": \"Monaco\",\r\n\t\"font_size\": 14,\r\n\t\"highlight_line\": true,\r\n\t\"highlight_modified_tabs\": true,\r\n\t\"ignored_packages\":\r\n\t[\r\n\t\t\"Vintage\"\r\n\t],\r\n\t\"scroll_past_end\": true,\r\n\t\"soda_folder_icons\": true,\r\n\t\"tab_size\": 4,\r\n\t\"theme\": \"Soda Dark 3.sublime-theme\",\r\n\t\"translate_tabs_to_spaces\": true,\r\n\t\"trim_trailing_white_space_on_save\": true\r\n}\r\n```\r\n\r\n#### Git, Gitx\r\n\r\nWe use [Git](http://git-scm.com/) as our SCM of choice and the latest version has been installed on your workstation. In addition, [Gitx](http://gitx.frim.nl/) has also been installed and provides a nice GUI for reviewing your changes prior to committing and viewing version history.\r\n\r\n[attach screenshots here]\r\n\r\n#### Homebrew, Homebrew Cask\r\n\r\n[Homebrew](http://brew.sh/) is a package manager for OS X (similar to apt-get on Ubuntu or yum on Fedora). You can use it to install packages of various software (e.g. _mysql_, _imagemagick_, _wget_, etc.). [Homebrew Cask](http://caskroom.io/) extends Homebrew and provides a CLI for installing OS X binaries.\r\n\r\nTo use:\r\n\r\n```Shell\r\n$ brew install redis\r\n$ brew cask install google-drive\r\n```\r\n\r\n#### RVM\r\n\r\n[RVM](http://rvm.io/)(Ruby Version Manager) is a tool that allows you to manage and work with multiple ruby versions and environments.\r\n\r\nListing installed rubies:\r\n\r\n```Shell\r\n$ rvm list\r\n```\r\n\r\nInstalling a version of ruby\r\n\r\n```Shell\r\n$ rvm install ruby-2.1.0\r\n```\r\n\r\nUsing a version of ruby\r\n\r\n```Shell\r\n$ rvm use ruby-2.1.0\r\n```\r\n\r\nIt is recommended that you read the [RVM Documentation](http://rvm.io/), in particular the sections about [upgrading](http://rvm.io/rvm/upgrading), [installing rubies](http://rvm.io/rubies/installing), [setting a default ruby](http://rvm.io/rubies/default), [gemsets](http://rvm.io/gemsets), and [best practices](http://rvm.io/rvm/best-practices).\r\n\r\n\r\n#### Other\r\n\r\n| Type | Installed | Notes |\r\n| ---- | --------- | ----- |\r\n| Browsers | Google Chrome, Firefox, Safari | |\r\n| Databases | MySQL, Postgres, SQLite, Redis | MySQL password: `password` |\r\n| Virtualization | VMWare Fusion, VirtualBox, Vagrant | |\r\n\r\n## Accounts\r\n\r\nThere are several accounts you'll need to have setup and configured in your first couple of days. Some of these accounts, like email, will be provided for you; other's you'll need to setup yourself. This section provides an overview and brief explanation of the accounts you'll need.\r\n\r\n### Email (provided)\r\n\r\nSelf-explanitory. Once you have your email address and password, you can login to see your email at [http://mail.fluidmedia.ca](http://mail.fluidmedia.ca). We use Google Apps for Business so if you use Gmail as your personal email service, this should feel right at home.\r\n\r\n### Basecamp (provided)\r\n\r\n[Basecamp](https://basecamp.com/) is a project management tool and probably the most popular Ruby on Rails application running in production. We use Basecamp to manage projects, to correspond with clients, and to correspond with other team members. Once you have your login and password, you can login at [https://launchpad.37signals.com/basecamp](https://launchpad.37signals.com/basecamp).\r\n\r\n### Messages.app (provided)\r\n\r\nThroughout the day, we use the Messages app to communicate with other team members in and out of the office. The Messages app is already installed on your machine but you'll need to setup your account with the credentials provided.\r\n\r\nOpen the Messages application, then select _Preferences_ (you can use `cmd + ,` as a shortcut). In the _Preferences_ dialog, click on _Accounts_ then click the _+_ icon to add your account. Select _Other messages account..._ and hit _Continue_. For _Account Type_ select _Jabber_, for _Account Name_ and _Password_ enter the login information you've been provided. Set the _Server_ to `optimus2.fluidmedia.com`, the _Port_ to `5223` and make sure _Use SSL_ is selected. Finally, click on _Create_.\r\n\r\nThis will log you onto the chat server and you should see everyone in the organization.\r\n\r\n#### Chat Rooms\r\n\r\nAlong with communicating with other team members directly, we also have chatroom setup for general discussions. To join, hit `cmd + r` on your keyboard. In the dialog, enter `devchat` for _Room Name_ and hit _Go_.\r\n\r\n### Github\r\n\r\nGithub is a hosted Git (discussed later) service provider and where we keep the majority of our code. You'll need a Github account if you don't already have one. When signing up, we recommend that you use your personal email. This way you can keep your account if you ever leave Fluid Media. Go to [https://github.com](https://github.com) to sign up or sign in. Once your account is created, we'll add you to the necessary organizations and repos.\r\n\r\n### Bitbucket\r\n\r\nBitbucket is another hosted source control service provider that offers both Git and Hg support (both of these will be discussed later). The bulk of our .NET projects is hosted on Bitbucket. The signup for Bitbucket is a little easier as it allows you to login via your Google or Github account. You can also create an account if you prefer by visiting [https://bitbucket.org](https://bitbucket.org). Once your account is created, we'll add you to the necessary organizations and repos.\r\n\r\n### Beanstalk (provided)\r\n\r\nBeanstalk is yet another hosted source control service provider although it only houses our older projects. Access is by invitation only so you'll receive an email with instructions on how to setup your account.\r\n\r\n### Trello\r\n\r\nTrello is an organization tool that provides virtual [Kanban](http://en.wikipedia.org/wiki/Kanban_board) boards. We use Trello to manage tasks for a particular project/sprint. The easiest way to get started with Trello is to signup via your Google (personal) account at [https://trello.com/signup](https://trello.com/signup). Once your account is created, we'll add you to the necessary organizations.\r\n\r\n## Git\r\n\r\nThis section will outline the fundamentals of using Git, including 1) configuration 2) basic usage 3) project workflow.\r\n\r\n### Configuration\r\n\r\nBefore you can begin using Git, you'll need to configure some basic properties, mainly your username and your email. These will be used to identify your commits. In addition, you'll also configure an authentication mechanism.\r\n\r\nTo configure these settings, you'll need to open up your terminal.\r\n\r\n#### Username\r\n\r\nFirst you need to tell git your name, so that it can properly label the commits you make.\r\n\r\n```Shell\r\n$ git config --global user.name \"Your Name Here\"\r\n# Sets the default name for git to use when you commit\r\n```\r\n\r\n#### Email\r\n\r\nGit saves your email address into the commits you make. Sites like Github use this information to associate your commits with your Github account. Your email address should be the same one associated with your Github/Bitbucket account.\r\n\r\n```Shell\r\n$ git config --global user.email \"your_email@example.com\"\r\n# Sets the default email for git to use when you commit\r\n```\r\n\r\n#### HTTPS Authentication\r\n\r\nGit supports both HTTPS and SSH. Which you use is up to you although Github/Bitbucket recommend HTTPS. This section describes working with HTTPS repos, please see the [SSH Authentication](#ssh-authentication) section on working with SSH repos.\r\n\r\nWhen you clone a HTTPS repo, you'll be asked to provide your username and password. If you don't want to keep typing your username and password everytime you talk with the remote server, you'll need to configure your _credential.helper_.\r\n\r\nThis should already be configured on your system as Git was installed via Homebrew. As a sanity check, verify that your credential.helper is properly set\r\n\r\n```Shell\r\n$ git config --global credential.helper\r\nosxkeychain\r\n```\r\n\r\n> On Linux this is slightly different. The credential.helper will store your credentials in memory for a certain time (default is 15 minutes). You can change this timeout if you like\r\n```Shell\r\n$ git config --global credential.helper 'cache --timeout=3600'\r\n# Set the cache to timeout after 1 hour (setting is in seconds)\r\n```\r\n\r\n#### SSH Authentication\r\n\r\nWhen you clone a repo using SSH, your SSH keys are used for authentication. The following describes how to generate an SSH key pair and add it to Github and Bitbucket.\r\n\r\n##### Generating SSH Keys\r\n\r\nTo generate a new SSH key, copy and paste the text below, making sure to substitute in your email. The default settings are preferred, so when you're asked to \"enter a file in which to save the key,\"\" just press enter to continue.\r\n\r\n```Shell\r\n$ ssh-keygen -t rsa -C \"your_email@example.com\"\r\n# Creates a new ssh key, using the provided email as a label\r\n# Generating public/private rsa key pair.\r\n# Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]\r\n```\r\n\r\nNext, you'll be asked to enter a passphrase. Please don't leave these blank, enter an actuall passphrase.\r\n\r\n```Shell\r\nEnter passphrase (empty for no passphrase): [Type a passphrase]\r\n# Enter same passphrase again: [Type passphrase again]\r\n```\r\n\r\nWhich should give you something like this:\r\n\r\n```Shell\r\nYour identification has been saved in /Users/you/.ssh/id_rsa.\r\n# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.\r\n# The key fingerprint is:\r\n# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com\r\n```\r\n\r\nTo prevent entering your passphrase over and over again, add your new key to the ssh-agent.\r\n\r\n```Shell\r\n$ ssh-add id_rsa\r\n```\r\n\r\n##### Adding your SSH key to Github and Bitbucket\r\n\r\nThe [following guide](https://help.github.com/articles/generating-ssh-keys#step-3-add-your-ssh-key-to-github) provides clear instructions how to add your SSH key to Github. Similarly, [this guide](https://confluence.atlassian.com/pages/viewpage.action?pageId=270827678#SetupSSHforGitandMercurialonMacOSX/Linux-Step6.InstallthepublickeyonyourBitbucketaccount) has instructions on adding your SSH key to Bitbucket.\r\n\r\nThat's all there is to it. You are now ready to clone both HTTPS and SSH repos on both Github and Bitbucket.\r\n\r\n### Basic Usage\r\n\r\nThis section describes the basics of using Git. You'll learn how to initialize an empty Git reposity, track files, create and undo commits, branch and merge, work with remotes, and git specific concepts like rebasing. Let's get started.\r\n\r\n#### Initializing a Git repository\r\n\r\nStart by creating a new folder anywhere on you filesystem. In these examples we're using the Destkop.\r\n\r\n```Shell\r\n$ cd ~/Desktop\r\n$ mkdir my-awesome-project && cd my-awesome-project\r\n```\r\n\r\nWithin the newly created folder, create a `README.txt` file (afterall, all awesome projects contain a README). Using an editor, add some content to the README file.\r\n\r\n```Shell\r\n$ touch README.txt\r\n$ echo \"This is my awesome project.\" >> README.txt\r\n```\r\n\r\nGreat, our project is underway and while we don't have much, it's never to early to start tracking your changes with Git. Start by initializing a Git repository within our project folder.\r\n\r\n```Shell\r\n$ git init\r\nInitialized empty Git repository in /Users/tdurden/Desktop/my-awesome-project/.git/\r\n```\r\n\r\nWith Git initialized, we can now use the `git` command within this directory to perform various operations. Let's start by checking the status.\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\n#\r\n# Initial commit\r\n#\r\n# Untracked files:\r\n#   (use \"git add <file>...\" to include in what will be committed)\r\n#\r\n#\tREADME.txt\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n```\r\n\r\nThe `git status` command provides information about the current state of our repository. It tells us that we're on the `master` branch (more on this later) and it tells us that we have some untracked files (the README.txt file that we created in the previous step).\r\n\r\n#### Adding files to repository\r\n\r\nWhen you create new files within a Git repository, they are untracked by default. You need to tell Git to track the files you want. As you may have guessed from the output of `git status`, tracking of files is done via the `git add` command. Let's track the README.txt file we created earlier and check the output of `git status` again.\r\n\r\n```Shell\r\n$ git add README.txt\r\n$ git status\r\n# On branch master\r\n#\r\n# Initial commit\r\n#\r\n# Changes to be committed:\r\n#   (use \"git rm --cached <file>...\" to unstage)\r\n#\r\n#\tnew file:   README.txt\r\n#\r\n```\r\n\r\nGit is now tracking our README.txt file. From the output of `git status`, we can see that Git recognizes our README.txt as a new file.\r\n\r\n> If we had multiple files to add, it would be tedious to call `git add` on every file. In these situations, you can use `git add .` to add all untracked files.\r\n\r\n#### Committing state\r\n\r\nWe're satisfied with the current state of our project so let's go ahead and commit our changes. You can think of commits as _snapshots_ of your project during a point in time.\r\n\r\n```Shell\r\n$ git commit -m \"Initial Commit\"\r\n[master (root-commit) 4634299] Initial Commit\r\n 1 file changed, 1 insertion(+)\r\n create mode 100644 README.txt\r\n```\r\n\r\nGreat, our project state is now saved. We can once again perform a `git status` to ensure we didn't miss anything.\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\nnothing to commit, working directory clean\r\n```\r\n\r\nThe output is fairly self-explanitory. We have nothing to commit (we just committed our changes) and our working directory is clean (we don't have any conflicts or untracked files).\r\n\r\n#### Modifying files\r\n\r\nLet's make some more changes to our `README.txt` file. Awesome projects always include license info so let's add that next. Open `README.txt` in your favourite editor and change its contents as follows:\r\n\r\n```Text\r\nThis is my awesome open source project.\r\n\r\nReleased under the MIT License.\r\n```\r\n\r\nSave the file. Let's perform a `git status` to see where we're at.\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\n# Changes not staged for commit:\r\n#   (use \"git add <file>...\" to update what will be committed)\r\n#   (use \"git checkout -- <file>...\" to discard changes in working directory)\r\n#\r\n#\tmodified:   README.txt\r\n```\r\n\r\nBecause git is already tracking `README.txt`, the output now shows that it has been modified. Let's save the state by first staging the file and then committing.\r\n\r\n```Shell\r\n$ git add README.txt\r\n$ git commit -m \"Updated README with license information\"\r\n[master 6d443f3] Updated README with license information\r\n 1 file changed, 3 insertions(+), 1 deletion(-)\r\n```\r\n\r\n> The above might be confusing at first. Why are we calling `git add` again? Why is saving state a 2-step process? To answer this, we need to introduce the concept of a __staging area__. Most version control systems use 2 places to store data, your working copy (the files and folders you're currently using) and the datastore (where the version control software decides how to pack and store your changes). In Git, there is a 3rd place called the _staging area_ or _index_. Using the staging area decouples the changes made to the working copy and what gets saved in Git by allowing the developer to build up their commits however they want.\r\n\r\n> To give a practical example, suppose you went on a caffeine-fueled hacking frenzy and implemented several features and fixed numerous bugs without saving state in-between. Without a staging area, you'd most likely be forced to create a giant commit that encompasses all these features and bug fixes - not ideal as it makes reverting difficult. Having a staging area allows you to 'cherry-pick' and 'stage' the changes you want (even from a single file) before packaging it up in a commit. This allows you to create small succinct commits.\r\n\r\n#### Ignoring files\r\n\r\nNext, we'll want to create a small text file to keep track of any minor _todos_ we need to perform as we're developing a specific feature. Go ahead and create the file.\r\n\r\n```Shell\r\n$ touch todos.txt\r\n```\r\n\r\nLet's do a `git status` to see where we're at\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\n# Untracked files:\r\n#   (use \"git add <file>...\" to include in what will be committed)\r\n#\r\n#\ttodos.txt\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n```\r\n\r\nNow if you think about it, this file doesn't really belong in source control. After all, the file will be specific to the developer using it and won't benefit from being versioned. Let's ask Git to ignore this file.\r\n\r\nIgnoring files in Git is super easy and accomplished by adding a special `.gitignore` file (the `.` at the beginning is important) to the root of the repository. The contents of this file list the files to ignore.\r\n\r\nLet's start by creating the `.gitignore` file\r\n\r\n```Shell\r\n$ touch .gitignore\r\n```\r\n\r\nOpen this newly created file inside your favourite editor, add the following line and save the changes.\r\n\r\n```Text\r\ntodos.txt\r\n```\r\n\r\nLet's do a `git status` to see if that worked.\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\n# Untracked files:\r\n#   (use \"git add <file>...\" to include in what will be committed)\r\n#\r\n#\t.gitignore\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n```\r\n\r\nHey great! `todos.txt` is no longer being listed and is being ignored by Git. As for the `.gitignore` file, that should be added to source control.\r\n\r\n\r\n```Shell\r\n$ git add .gitignore\r\n$ git commit -m \"Adds .gitignore to project\"\r\n[master 3083bd3] Adds .gitignore to project\r\n 1 file changed, 1 insertion(+)\r\n create mode 100644 .gitignore\r\n \r\n$ git status\r\n# On branch master\r\nnothing to commit, working directory clean\r\n```\r\n\r\n> The `.gitignore` file isn't only limited to matching files. You can ignore entire folders and specify glob patterns for ignoring certain types of files (e.g. `*.log`)\r\n\r\n> When working with frameworks like Ruby on Rails or .NET, you can find sample `.gitignore` files online that list commonly ignored components.\r\n\r\n#### Undoing commits\r\n\r\nIf you would like to revert a commit, Git provides several options that vary in how they modify the working copy. Each option is useful depending on your scenario. To illustrate the options, let's create a new file called `test.txt` and add some content.\r\n\r\n```Shell\r\n$ touch test.txt\r\n$ echo \"This is only a test\" >> text.txt\r\n```\r\n\r\nNext we'll add and commit this new file like we did previously with our README\r\n\r\n```Shell\r\n$ git add test.txt\r\n$ git commit -m \"Adds text.txt for testing\"\r\n[master 01d4b04] Adds text.txt for testing\r\n 1 file changed, 1 insertion(+)\r\n create mode 100644 test.txt\r\n```\r\n\r\n##### Normal revert\r\n\r\nIf we forgot to add something to the commit or forgot to include a modification, we can use the `git reset` command to do a normal revert.\r\n\r\n```Shell\r\n$ git reset HEAD~1\r\n$ git status\r\n# On branch master\r\n# Untracked files:\r\n#   (use \"git add <file>...\" to include in what will be committed)\r\n#\r\n#\ttest.txt\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n```\r\n\r\nAs we can see, a normal revert will return the working copy to the state it was prior to staging and committing.\r\n\r\nAdd and commit the file again before continueing.\r\n\r\n##### Soft revert\r\n\r\nIf we made a spelling mistake in our commit message or want to modify it slightly while leaving all committed changes in the staging area, we can use `git reset` with the `--soft` option.\r\n\r\n```Shell\r\n$ git reset --soft HEAD~1\r\n$ git status\r\n# On branch master\r\n# Changes to be committed:\r\n#   (use \"git reset HEAD <file>...\" to unstage)\r\n#\r\n#\tnew file:   test.txt\r\n#\r\n```\r\n\r\nAs we can see, a soft revert will leave the reverted changes in the staging area. This is especially useful if all you're doing is modifying the commit message.\r\n\r\nBefore we continue, let's unstage and remove the `test.txt` file as we'll no longer need it.\r\n\r\n```Shell\r\n$ git reset HEAD test.txt\r\n$ rm test.txt\r\n```\r\n\r\n##### Hard revert\r\n\r\nIf we completely messed up a previous commit and want to return our working copy to a prestine state, we can use the `git reset` with the `--hard` option.\r\n\r\nTo illustrate this, modify the README file\r\n\r\n```Text\r\nThis is my awesome open source project.\r\n\r\nReleased under the MIT License.\r\n\r\nTHIS CHANGE WILL ULTIMATELY BE EREASED\r\n```\r\n\r\nCommit the changes\r\n\r\n```Shell\r\n$ git add README.txt\r\n$ git commit -m \"Modifies README\"\r\n[master bb55d36] Modifies README\r\n 1 file changed, 3 insertions(+), 1 deletion(-)\r\n```\r\n\r\nNow, revert the changes\r\n\r\n```Shell\r\n$ git reset --hard HEAD~1\r\nHEAD is now at 3083bd3 Adds .gitignore to project\r\n$ git status\r\n# On branch master\r\nnothing to commit, working directory clean\r\n```\r\n\r\nAs you can see, using the `--hard` option will not only revert the commit, but will also discard any changes made in that commit from the working copy, essentialy restoring it to the state of a previous commit.\r\n\r\n> In the examples above, all `git reset` commands were called with `HEAD~1`. The number following the `~` (tilde) indicates the number of commits to undo.\r\n\r\n#### Branching and Merging\r\n\r\nGits real power lies in branching and merging. Branching allows you to diverge your code from the main line of development and continue to do work without messing with the main line. Similarly, merging allows to merge a divergent branch back into the main line of development.\r\n\r\n> ##### Why bother?\r\n\r\n> Why not just modify and commit to the main line of development? While this process works fine for small projects with only one or two developers, it quickly breaks down as project complexity increases or more people are added to the project. \r\n\r\n> Here's a practical example. Let's assume that we have a web application that is already running in production and is being contributed to by several developers. One of these developers has been asked to implement an experimental feature that may or may not ship in a future version of the application. The commits for this experimental feature are all in the main line of development. Now let's assume that a critical bug has been discovered in production and another developer needs to quickly add a patch to fix the bug. Since all commits for this project are on the main line (including commits from an un-tested and partially implemented experimental feature) the developers now have a major problem. It will be difficult to commit the patch and deploy the fix without also exposing un-tested code to production.\r\n\r\n> This is where branching comes in. The developer working on the experimental feature could have created a seperate branch to house all their commits, leaving the main line of development unaffected. When the critical bug is discovered, the other developer can quickly patch the main line of development without also introducing unwanted commits to production. Once the experimental feature is complete and tested, the feature can be merged back into the main line for inclusion in a future release.\r\n\r\nWe'll see later how we can use Git's awesome branching and merging functionality to develop an ideal worflow for most projects. For now, let's just concentrate on the basics.\r\n\r\nWe've already seen one example of a branch. Recall the output of `git status` within our project directory.\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\nnothing to commit, working directory clean\r\n```\r\n\r\nAs you can see, all git repositories start with a main branch called the _master_ branch. Typically this branch will be the main line of development with branches diverging from and merging to this branch.\r\n\r\n##### Branching\r\n\r\nLet's introduce two new git commands. The first, `git branch` will list all branches in the repository. The second `git checkout` will allow to switch between branches as well as create new branches.\r\n\r\n```Shell\r\n$ git branch\r\n* [1] master\r\n```\r\n\r\nRight now we only have one branch, `master`. Let's create a new branch to isolate a new feature we want to work on. To create a new branch, use the `git checkout` command with the `-b` option followed by the name of the branch you would like created\r\n\r\n```Shell\r\n$ git checkout -b awesome-new-feature\r\nSwitched to a new branch 'awesome-new-feature'\r\n```\r\n\r\nThe above creates a new branch called `awesome-new-feature` and git has automatically switched to this new branch. Let's take a look at the output of `git branch`\r\n\r\n```Shell\r\n$ git branch\r\n* [1] awesome-new-feature\r\n  [2] master\r\n```\r\n\r\nAs expected, we now have two branches. The asterisk (*) indicates the currently selected branch.\r\n\r\nLet's once again modify the `README.txt` file with some information about our new feature. Open the file within your text editor and modify it to include the following\r\n\r\n```Text\r\nThis is my awesome open source project.\r\n\r\nFeatures\r\n========\r\n- awesome new feature\r\n\r\nReleased under the MIT License.\r\n```\r\n\r\nAs we've done previously, let's commit this changeset.\r\n\r\n```Shell\r\n$ git add README.txt \r\n$ git commit -m \"Adds documentation about awesome new feature\"\r\n[awesome-new-feature 45c63f5] Adds documentation about awesome new feature\r\n 1 file changed, 4 insertions(+)\r\n```\r\n\r\nThe output of the commit command will show you the branch along with the commit number (in our case, we've just commited to the `awesome-new-feature` branch and our commit number is `45c63f5`)\r\n\r\n> Unlike centralized version control systems which use revision numbers, Git uses hashes to uniquely identify commits.\r\n\r\nLet's confirm that the changes we just made did not in fact affect the master branch. We can use the `git log` command to view recent commits.\r\n\r\n```Shell\r\n$ git log --graph --decorate --oneline \r\n* 45c63f5 (HEAD, awesome-new-feature) Adds documentation about awesome new feature\r\n* 3083bd3 (master) Adds .gitignore to project\r\n* 6d443f3 Updated README with license information\r\n* 4634299 Initial Commit\r\n```\r\n\r\nThe `git log` command shows the commit hash, branch information, and commit messages of recent commits. As we can see, our last commit was made to the `awesome-new-feature` branch. Let's switch back to the master branch and see the output of `git log`. We can switch between branches using the `git checkout` command.\r\n\r\n```Shell\r\n$ git checkout master\r\nSwitched to branch 'master'\r\n\r\n$ git log --graph --decorate --oneline\r\n* 3083bd3 (HEAD, master) Adds .gitignore to project\r\n* 6d443f3 Updated README with license information\r\n* 4634299 Initial Commit\r\n```\r\n\r\nAs you can see, the changes we made in the `awesome-new-feature` branch did not affect the master branch. If you open the `README.txt` file in your editor, you'll notice that the changes we added are not there.\r\n\r\n##### Merging\r\n\r\nWe're satisfied with our awesome new feature and we now want to merge the commits in our `awesome-new-feature` branch back into the `master` branch. This is done via the `git merge` command.\r\n\r\n```Shell\r\n$ git merge awesome-new-feature\r\nUpdating 3083bd3..45c63f5\r\nFast-forward\r\n README.txt | 4 ++++\r\n 1 file changed, 4 insertions(+)\r\n```\r\n\r\nDon't worry about the output of the merge command just yet, we'll explain the concepts of _fast-forward_ and _rebase_ later in this guide. For now, let's focus on the state of our working copy. Take another look at the output of the `git log` command.\r\n\r\n```Shell\r\n$ git log --graph --decorate --oneline\r\n* 45c63f5 (HEAD, master, awesome-new-feature) Adds documentation about awesome new feature\r\n* 3083bd3 Adds .gitignore to project\r\n* 6d443f3 Updated README with license information\r\n* 4634299 Initial Commit\r\n```\r\n\r\nThe output shows that our working copy (`HEAD`), the master branch, and the awesome-new-feature branch are all pointing to the same last commit, meaning our changes have been successfully merged back into our master branch. If you inspect the `README.txt` file now, you'll notice that it's been updated with the modificatios we made in the `awesome-new-feature` branch.\r\n\r\nSince we're done with the `awesome-new-feature` branch, let's go ahead and delete it. This is accomplished with the `git branch` command and the `-d` option.\r\n\r\n```Shell\r\n$ git branch -d awesome-new-feature\r\nDeleted branch awesome-new-feature (was 45c63f5).\r\n```\r\n\r\n#### Working with Remotes\r\n\r\nThe Git repository that we've setup and have been using to date is only local to our machine. While this is one of the benefits of a distributed version control system, at some point you'll want to share your code and collaborate with other developers. To do this, we'll need to setup a remote. A remote is basically a git repo running on a git server somewhere and accessible to all developers on the project. This Git server can be self-hosted or provided via a git-hosting service like Github or Bitbucket. We'll use Github for this guide.\r\n\r\n##### Creating the remote repo\r\n\r\nLogin to Github and create a new repository. Name the repository as `my-awesome-project`, add a short description, make the repository _Public_ and make sure that the option _Initialize this repository with a README_ is unchecked. Click the _Create repository_ button.\r\n\r\nThe repo has been created and now Github provides us with some helpful hints on how to proceed. We'll want to follow the steps outlined in the second option as we've already created a Git repository in previous steps. We'll start by first adding a remote using the `git remote add` command\r\n\r\n```Shell\r\n$ git remote add origin git@github.com:your-username/my-awesome-project.git\r\n```\r\n\r\nNext, we'll want to synchronize our local repository with the remote repository by _pushing_ our local changes to the remote. This is accomplished with the `git push` command\r\n\r\n```Shell\r\n$ git push -u origin master\r\nCounting objects: 12, done.\r\nDelta compression using up to 8 threads.\r\nCompressing objects: 100% (8/8), done.\r\nWriting objects: 100% (12/12), 1.15 KiB | 0 bytes/s, done.\r\nTotal 12 (delta 0), reused 0 (delta 0)\r\nTo git@github.com:bjedrocha/my-awesome-project.git\r\n * [new branch]      master -> master\r\nBranch master set up to track remote branch master from origin.\r\n```\r\n\r\nIf you now refresh the Github project page, you'll notice that our files and changes have been synchronized with the remote. We can now invite other collaborators to contribute to our project.\r\n\r\n> In the above example, we called `git push` with the `-u` option. This tells Git to associate the remote branch `master` with our local branch `master`. We'll see shortly how this information is used.\r\n\r\n##### Synchronization\r\n\r\nOpen the `README.txt` file in your editor and make some change (whatever you want). Next, we'll commit this change as we've done previously.\r\n\r\n```Shell\r\n$ git add README.txt\r\n$ git commit -m \"Minor change to README.txt\"\r\n[master 025c6a6] Minor change to README.txt\r\n 1 file changed, 1 insertion(+)\r\n```\r\n\r\nGo back to the repo's Github page and click the _commits_ link to view the commits to this project. What gives? Our last commit isn't listed. Let's go back into the terminal and run `git status`.\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\n# Your branch is ahead of 'origin/master' by 1 commit.\r\n#   (use \"git push\" to publish your local commits)\r\n#\r\nnothing to commit, working directory clean\r\n```\r\n\r\nIn the previous step when we first pushed our changes to the remote with the `git push` command, we added the `-u` option to have our local `master` branch track the remote `master` branch. Now we can see that Git is using this information to tell is that our local `master` branch is ahead of the remote `master` branch (`origin/master`) by 1 commit. In order to publish our changes and synchronize our local branch with the remote, we'll need to use `git push` to push up the changes.\r\n\r\n```Shell\r\n$ git push\r\nCounting objects: 5, done.\r\nDelta compression using up to 8 threads.\r\nCompressing objects: 100% (3/3), done.\r\nWriting objects: 100% (3/3), 324 bytes | 0 bytes/s, done.\r\nTotal 3 (delta 1), reused 0 (delta 0)\r\nTo git@github.com:bjedrocha/my-awesome-project.git\r\n   45c63f5..025c6a6  master -> master\r\n```\r\n\r\nLet's quickly run `git status` again to see where we're at.\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\nnothing to commit, working directory clean\r\n```\r\n\r\nExcellent, Git no longer says that we're ahead of `origin/master` by 1 commit. Indeed, if you go back to the commits page on Github and refresh, you'll now see our last commit.\r\n\r\nIn the same way that we must _push_ our changes to see them reflected on the remote repository, we'll also need to _pull_ down changes added by other developers. For the purposes of this guide, let's simulate another developer's changes by using Github's inline editor to make changes to our `README.txt` file. Go back to the project's Github page and click on the `README.txt` file in the file listing. Click on the _Edit_ button and make a change (whatever you want) to the file. Commit the changes.\r\n\r\nIf you view the commit history on the Github page, you'll notice our last commit is listed. Let's go back to the terminal and for illustrative purposes, run the following command\r\n\r\n```Shell\r\n$ git remote update\r\n```\r\n\r\nDon't worry about the command for now, we're just using it to illustrate a point. Now, perform a `git status`\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\n# Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.\r\n#   (use \"git pull\" to update your local branch)\r\n#\r\nnothing to commit, working directory clean\r\n```\r\n\r\nThis time we're _behind_ `origin/master` by 1 commit. In order to synchronize our local `master` branch with the remote, we can use the `git pull` command\r\n\r\n```Shell\r\n$ git pull\r\nUpdating 025c6a6..50d5492\r\nFast-forward\r\n README.txt | 3 ++-\r\n 1 file changed, 2 insertions(+), 1 deletion(-)\r\n```\r\n\r\nIf you check `git status` and `git log`, you'll see that we're now synched with the remote `master` branch.\r\n\r\n```Shell\r\n$ git status\r\n# On branch master\r\nnothing to commit, working directory clean\r\n\r\n$ git log --graph --decorate --oneline\r\n* 50d5492 (HEAD, origin/master, master) Updated README.txt\r\n* 025c6a6 Minor change to README.txt\r\n* 45c63f5 Adds documentation about awesome new feature\r\n* 3083bd3 Adds .gitignore to project\r\n* 6d443f3 Updated README with license information\r\n* 4634299 Initial Commit\r\n```\r\n\r\n#### Cloning Repositories\r\n\r\nThere are two main approaches for getting a Git project - initializing a Git repository within an existing directory or cloning an existing repository. We've already seen how to do the first one so let's take a look at how we clone an existing repository.\r\n\r\nTo clone, the first thing you'll need is the _clone url_ of the repository. Go to the Github project page for this Employee Guide ([https://github.com/fmitech/platypus-node](https://github.com/fmitech/platypus-node)). In the right-hand navigation control, you'll see _HTTPS clone URL_ (or _SSH clone URL_). If you previously setup HTTPS Authentication, make sure you use the _HTTPS clone URL_. If you previously setup SSH Authentication, make sure you use the _SSH clone URL_. If you setup both, you can use either one. Copy the URL into your clipboard (or click the little button next to the URL).\r\n\r\nOpen the Terminal and navigate to your your `Development` directory\r\n\r\n```Shell\r\n$ cd ~/Development\r\n```\r\n\r\nTo clone the repository, we'll use the `git clone` command\r\n\r\n```Shell\r\n$ git clone https://github.com/fmitech/platypus-node.git\r\nCloning into 'platypus-node'...\r\nremote: Reusing existing pack: 149, done.\r\nremote: Total 149 (delta 0), reused 0 (delta 0)\r\nReceiving objects: 100% (149/149), 24.74 KiB | 0 bytes/s, done.\r\nResolving deltas: 100% (77/77), done.\r\nChecking connectivity... done\r\n```\r\n\r\n> If you're using HTTPS Authentication, you'll be asked to provide your Github username and password in the above step. If you're using SSH Authentication, you shouldn't be prompted provided you used the _SSH clone URL_.\r\n\r\nThat's it, you have now successfully cloned an existing Git repository. Go into the directory and do a `git status` if you'd like to confirm. Otherwise, open the project within your text editor and start contributing!\r\n\r\n##### A note about cloning and branches\r\n\r\nWhen you clone an existing repository, by default, only the master branch will be checked out even though the project may have several other branches. For example, the Employee Guide has both a `master` and a `development` branch. To see all branches (local and remote) we can use the `git branch` command with the `-a` option\r\n\r\n```Shell\r\n$ git branch -a\r\noutput\r\n```\r\n\r\nTo actually checkout the `development` branch and have it track the remote `development` branch, we can again use the `git checkout` command with the `-b` option (like we used when creating branches) but this time also provide a second argument, the name of the remote branch\r\n\r\n```Shell\r\n$ git checkout -b development origin/development\r\noutput\r\n```\r\n\r\nYou are now tracking both the `master` and `development` branches.\r\n\r\n\r\n### Git Workflow\r\n\r\nNow that you have a basic understanding of how to use Git, we'll move onto workflows. A Git workflow establishes a set of practices on how to use Git in day to day development. While there is no _\"the one\"_ workflow (indeed it really depends on the project), we've had great success using the flow introduced by Vincent Driessen. Read through it [here](http://nvie.com/posts/a-successful-git-branching-model/?). It is important that you understand the workflow as you'll be using it daily when developing.\r\n\r\n### A note about GUI Git\r\n\r\nWhile there are numerous GUI clients available for Git, none of them come close to the power you get from using the command line. However, there is one GUI tool that greatly simplifies one aspect of working with Git - staging and committing files. In our examples above, we used the `git add` command to stage files followed by the `git commit -m` command to actually commit them. Instead, we can use [GitX](http://gitx.frim.nl/). The tool is already installed on your workstation and can be invoked via the `gitx` command from within your working copy.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}